Tato dokumentace by mněla obsahovat vše potebné k mim pytoch projektům
https://www.learnpytorch.io/00_pytorch_fundamentals/

Nejčastjší errory v PyToch a v deeplearnig
    Tensors not right datatype
        Navzájem se soubou můžou pracovat jen tensory se stejným datatypem
    Tensors not right shape
        Špatná velikost tenzoru -> tenzory nejsou stejně velké
    Tensor not on the right device
        Tensory nejsou uloženy na stejném místě. Místa -> CPU, GPU, CUDA

Tensors / listy
    Jedná se o číselné hodnoty v různých formátech.
    V této knihovně se tensory vytváří pomocí příkazu -> torch.tensor()
    Existují 3 základní typy :

    Scalar / Skalár
        Bez žádných dimenzí čistě jedno číslo.
            Bod
        Je potřeba použít metodu .item() abych získali scalar jako normální číslov Pythonu

    Vector / 1D lyst / Vector
        Má jednu dimenzi -> jakoby jeden směr.
            Čára
        Klasický lyst v Pythonu.
        Slkádá se z vícce čísel v hrantých závorkách.
        Např. [1, 2, 3]
    
    Matrix / 2D list
    Má dvě dimenze -> dva různé směry
        čtverec

    Tensor / 3D list
    Má tři dimenze -> má tři různé směry
        Krychle

Datatypy Tensorů
    Jednotlivé tensory můžou mít různé data typy (bolean, float16, float32, ...)
    Jedná se to s jakou přesností se ukládají data tensoru
    float32 = jedno číslo bude zabírat 32 bitu v pamněti.

Získávání dat z tensoru
    Pro získání datatypu ->         tensor.dtype
    Pro získání shape / tvar ->     tensor.shape
    Pro získání device ->           tensor.device

Manipuleace s tensory
    Existuje základních pět operací u které lze provádět při vytváření euronových sítí:
        Přidání                     Addition
        Odčítání (odebírání)        Subtraction
        Násobení - elemetary-wise   Mutipication - elemetary-wise 
        Dělení                      Division
        Násobení matrixů            Matrix multiplication

Násobení matrixu -> https://www.mathsisfun.com/algebra/matrix-multiplying.html
    Pro lepší představu: http://matrixmultiplication.xyz/
    @ - značka pro nasobeni matrixu
    Jedná so o sčítání dvou matryxů (2D listů).
    Existují 2 pravidla pro násobení matrixu, která když se edodrží tak dojde k erroru
        1. Tensory musí mít stejný tvar 
            (X, Y) - X = počet listů (počet sloupců)
                   - Y = počet hodnot (délka řádku)
            (X, Y) @ (X, Y) -> nebude fungovat
            (Y, X) @ (X, Y) -> bude fungovat
            Protože platí že Y v jednom listu se musí ronat Y v listu druhém
            to stejné platí pro X
            Je to spůsobeno tím že při násobení matrixů násobíme řádek 1. listu se sloupcem listu 2.
            Tedy pokud nemáme stejně dlouhé řádky i sloupce hodnoty se nebudou mít s čím násobit.
        2. Výsledný matrix bude mít tvar X z matrixu 1. a Y z matrixu 2.
            Tedy:
            (3, 2) @ (2, 3) = (3, 3)
            Porože platí že tvar se bude rovnat počet lisů z 1. matrixu a popočet hodnot z 2, matrixu
            prože zase platí že násobíme řádky z 1. matrixu se sloupci z 2. matrixu
        To lze řešit pomocí Transpose:
            Transpose
                Zmnění v metrixu řádky na sloupce -> X -> Y a Y -> X
                Volání: .T
    Tímto způsobem :
        Pro získání první hodnoty se musí vynásobyt první hodnota v prvním
        řádku listu v jednom metrixu s první hodnotou prvního sloupce
        v listu druhém. A stejným spusobem to pokračuje na druhé hodnoty a třetí a ...
        Takto zíáskané hodnoty se navtájem sečtou a výsledným součtem těch to hodnot je 
        první pole v novém metrixu.
    Sčítání pokračuje tímto způsobem:
        Nejprve se musí sečíts první řádek se všemi sloupci v metrixu.
        Nasledně drůhý řádek se všemi sloupci pak třetí ...

Úpravy tensoru  
    Reshaping
        Zmnění tvar tensoru podle definovaného tvaru
        .reshape(První hodnota = počet řádků, Druhá hodnota = počet sloupců)
    View
        Zobrazí tenzor požadovaným spůsobem.
        Veiw hodnoty zdílí pamněť originalu -> zmněněním vei se zmnění i original
    Stacking
        Spojí tensory dohromady buď podle sloupců (vstack) nebo podle řádku (hstack)
        Např. A = [1, 2]         
              B = [3, 4]
              torch.vsack((A, B)) = tensor([[1],
                                            [2],
                                            [3],
                                            [4]])
              torch.hsack((A, B)) = tensor([[1], [2], [3], [4]])
    Squeeze 
        Odstraní 1 dimezi z tensoru (řadek)
    Unsqueeze
        Přidá 1 dimenzi do tensoru
    Permute 
        Vrátí view vstupní hodnoty s nějak přehozenými demenzemi.
    
Tvar / Shape
    Tvar určuje jak velký je list a kolik listů je v listu.     
    Prozor záleží na typu listu.
    List = [1, 2, 3]        Shape: (3)          1D, List        List ==     Array ==        Vektor
    List = [[1, 2, 3],      Shape: (2, 3)       2D, Matrix      Python      Programování    Matematika
            [1, 2, 3]]
    List = [[[1, 2, 3],    Shape: (3, 2, 3) = tři listy po dvou listech s třemi hodnotami
                [1, 2, 3]],                     3D, Array
            [[1, 2, 3],
                [1, 2, 3]],
            [[1, 2, 3],
                [1, 2, 3]]]

torch.tensor(X)         X, Y = zvolená hodnota
    Vytvoří tenzor na základě X.
    Pro každý typ tenzoru je nutné zdat X jinak :

    Scalar -> torch.tensor(X) 
    Vector -> torch.tensor([X, Y]) 
    V případě že se jedná o skalar je potřeba použít metodu .item()

torch.rand(X)           X = zvolená hodnota
    Vytvoří tenzor s tvarem X.
    Tento tensor v sobě budemít náhodné hodnoty.

torch.zeros(X)          X = zvolená hodnota
    Vytvoří tenzor o velikosti X pouze s nulami.

torch.arange(X)         X = zvolená hodnota
    Vytvoří řadu čísel. 
    Lze aplikovat tůzné parametry -> torch.arange(start=0, end=1000, step=77)

torch.matmul(tensor1, tensor2) = torch.mm(tensor1, tensor2)  # je to stejné
    Vynásobí mezi sebou zadané tenzory (v tomto případě tensor1 a tensor2)
Transpose
    Zmnění v metrixu řádky na sloupce -> X -> Y a Y -> X
    Volání: .T
Agregace
    Agregace =  hledání: sumi, min, max, mean...
    mean = průměr
    argmin(tensor) - najde idenx minimalni hodnoty v tensoru
    argmax(tensor) - najde idex maximalni hodnoty v tesnoru